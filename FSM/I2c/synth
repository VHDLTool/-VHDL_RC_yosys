
3. Executing SYNTH_COOLRUNNER2 pass.

3.1. Executing Verilog-2005 frontend: /opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_sim.v
Parsing Verilog input from `/opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\IBUF'.
Generating RTLIL representation for module `\IOBUFE'.
Generating RTLIL representation for module `\ANDTERM'.
Generating RTLIL representation for module `\ORTERM'.
Generating RTLIL representation for module `\MACROCELL_XOR'.
Generating RTLIL representation for module `\FDCP'.
Generating RTLIL representation for module `\FDCP_N'.
Generating RTLIL representation for module `\LDCP'.
Generating RTLIL representation for module `\LDCP_N'.
Generating RTLIL representation for module `\BUFG'.
Generating RTLIL representation for module `\BUFGSR'.
Generating RTLIL representation for module `\BUFGTS'.
Generating RTLIL representation for module `\FDDCP'.
Generating RTLIL representation for module `\FTCP'.
Generating RTLIL representation for module `\FTCP_N'.
Generating RTLIL representation for module `\FTDCP'.
Generating RTLIL representation for module `\FDCPE'.
Generating RTLIL representation for module `\FDCPE_N'.
Generating RTLIL representation for module `\FDDCPE'.
Successfully finished Verilog frontend.

3.2. Executing HIERARCHY pass (managing design hierarchy).

3.2.1. Analyzing design hierarchy..
Top module:  \I2C_slave

3.2.2. Analyzing design hierarchy..
Top module:  \I2C_slave
Removed 0 unused modules.

3.3. Executing PROC pass (convert processes to netlists).

3.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

3.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

3.3.4. Executing PROC_INIT pass (extract init attributes).

3.3.5. Executing PROC_ARST pass (detect async resets in processes).

3.3.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

3.3.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

3.3.8. Executing PROC_DLATCH pass (convert process syncs to latches).

3.3.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.3.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.3.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.3.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~83 debug messages>

3.4. Executing FLATTEN pass (flatten design).

3.5. Executing TRIBUF pass.

3.6. Executing SYNTH pass.

3.6.1. Executing PROC pass (convert processes to netlists).

3.6.1.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.6.1.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

3.6.1.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

3.6.1.4. Executing PROC_INIT pass (extract init attributes).

3.6.1.5. Executing PROC_ARST pass (detect async resets in processes).

3.6.1.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

3.6.1.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

3.6.1.8. Executing PROC_DLATCH pass (convert process syncs to latches).

3.6.1.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.6.1.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.6.1.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.6.1.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 5 unused cells and 50 unused wires.
<suppressed ~48 debug messages>

3.6.4. Executing CHECK pass (checking for obvious problems).
Checking module I2C_slave...
Found and reported 0 problems.

3.6.5. Executing OPT pass (performing simple optimizations).

3.6.5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.6.5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port A of cell $verific$i121$I2C_slave.vhd:285$273: \done_flag -> 1'1
      Replacing known input bits on port A of cell $verific$i116$I2C_slave.vhd:284$270: \done_flag -> 1'1
      Replacing known input bits on port A of cell $verific$i106$I2C_slave.vhd:271$265: \done_flag -> 1'0
      Replacing known input bits on port B of cell $verific$i256$I2C_slave.vhd:448$371: \enable_module_r -> 1'1
      Replacing known input bits on port A of cell $verific$i252$I2C_slave.vhd:446$367: \enable_module_r -> 1'1
      Replacing known input bits on port A of cell $verific$i234$I2C_slave.vhd:418$355: \enable_module_r -> 1'0
      Replacing known input bits on port A of cell $verific$i285$I2C_slave.vhd:480$389: \enable_module_slave_ack -> 1'1
      Replacing known input bits on port A of cell $verific$i279$I2C_slave.vhd:470$388: \enable_module_slave_ack -> 1'0
      Replacing known input bits on port A of cell $verific$i330$I2C_slave.vhd:532$420: \enable_module_w -> 1'1
      Replacing known input bits on port B of cell $verific$i325$I2C_slave.vhd:530$415: \enable_module_w -> 1'1
      Replacing known input bits on port A of cell $verific$i324$I2C_slave.vhd:530$414: \enable_module_w -> 1'1
      Replacing known input bits on port A of cell $verific$i304$I2C_slave.vhd:506$400: \enable_module_w -> 1'0
      Replacing known input bits on port A of cell $verific$i358$I2C_slave.vhd:574$437: \enable_module_master_ack -> 1'1
      Replacing known input bits on port A of cell $verific$i351$I2C_slave.vhd:557$435: \enable_module_master_ack -> 1'0
      Replacing known input bits on port A of cell $verific$i57$I2C_slave.vhd:204$237: \done_flag -> 1'1
      Replacing known input bits on port A of cell $verific$i52$I2C_slave.vhd:203$233: \done_flag -> 1'1
      Replacing known input bits on port A of cell $verific$i90$I2C_slave.vhd:245$255: \done_flag -> 1'1
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~47 debug messages>

3.6.5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.6.5.6. Executing OPT_DFF pass (perform DFF optimizations).
Changing const-value async load to async reset on $verific$w_done_reg_reg$I2C_slave.vhd:536$428 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$sm_state_reg$I2C_slave.vhd:310$295 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$sda_w_reg_reg$I2C_slave.vhd:536$427 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$sda_slave_ack_reg_reg$I2C_slave.vhd:484$394 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$sda_reg_start_reg$I2C_slave.vhd:374$336 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$sda_prev_reg_start_reg$I2C_slave.vhd:374$337 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$scl_reg_reg$I2C_slave.vhd:347$321 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$scl_prev_reg_reg$I2C_slave.vhd:347$322 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$read_req_reg_reg$I2C_slave.vhd:310$302 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$r_done_reg_reg$I2C_slave.vhd:450$381 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$end_slave_ack_reg_reg$I2C_slave.vhd:484$395 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$end_master_ack_reg_reg$I2C_slave.vhd:578$443 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$enable_module_w_reg$I2C_slave.vhd:536$431 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$enable_module_slave_ack_reg$I2C_slave.vhd:484$396 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$enable_module_r_reg$I2C_slave.vhd:450$385 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$enable_module_master_ack_reg$I2C_slave.vhd:578$445 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$en_w_reg$I2C_slave.vhd:310$299 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$en_slave_ack_reg$I2C_slave.vhd:310$298 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$en_r_reg$I2C_slave.vhd:310$297 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$en_master_ack_reg$I2C_slave.vhd:310$300 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$done_flag_reg$I2C_slave.vhd:310$296 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_w_reg_reg$I2C_slave.vhd:536$430 ($aldff) from module I2C_slave.
Removing never-active async load on $verific$data_w_reg$I2C_slave.vhd:310$309 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_valid_reg_reg$I2C_slave.vhd:310$301 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_to_master_reg_reg$I2C_slave.vhd:310$305 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_read_reg_reg$I2C_slave.vhd:450$384 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_r_reg_reg$I2C_slave.vhd:310$306 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$data_r_reg$I2C_slave.vhd:450$382 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$d_data_valid_reg_reg$I2C_slave.vhd:332$315 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$continue_reg_reg$I2C_slave.vhd:578$444 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$cmd_reg_reg$I2C_slave.vhd:310$304 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$bits_w_processed_reg_reg$I2C_slave.vhd:536$429 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$bits_r_processed_reg_reg$I2C_slave.vhd:450$383 ($aldff) from module I2C_slave.
Changing const-value async load to async reset on $verific$addr_reg_reg$I2C_slave.vhd:310$303 ($aldff) from module I2C_slave.

3.6.5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

3.6.5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.5.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.5.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~49 debug messages>

3.6.5.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.5.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.5.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.5.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.5.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.5.16. Finished OPT passes. (There is nothing left to do.)

3.6.6. Executing FSM pass (extract and optimize FSM).

3.6.6.1. Executing FSM_DETECT pass (finding FSMs in design).

3.6.6.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.6.6.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.6.6.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.6.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.6.6.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.6.6.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.6.6.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.6.7. Executing OPT pass (performing simple optimizations).

3.6.7.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.7.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.7.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~49 debug messages>

3.6.7.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.7.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.7.6. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $verific$w_done_reg_reg$I2C_slave.vhd:536$428 ($adff) from module I2C_slave (D = $verific$n1063$115, Q = \w_done_reg).
Adding EN signal on $verific$stop_reg_reg$I2C_slave.vhd:398$349 ($dff) from module I2C_slave (D = $verific$n514$80, Q = \stop_reg).
Adding EN signal on $verific$start_reg_reg$I2C_slave.vhd:374$338 ($dff) from module I2C_slave (D = $verific$n496$73, Q = \start_reg).
Adding EN signal on $verific$r_done_reg_reg$I2C_slave.vhd:450$381 ($adff) from module I2C_slave (D = $verific$n760$93, Q = \r_done_reg).
Adding EN signal on $verific$end_slave_ack_reg_reg$I2C_slave.vhd:484$395 ($adff) from module I2C_slave (D = $verific$n849$99, Q = \end_slave_ack_reg).
Adding EN signal on $verific$end_master_ack_reg_reg$I2C_slave.vhd:578$443 ($adff) from module I2C_slave (D = $verific$n1114$124, Q = \end_master_ack_reg).
Adding EN signal on $verific$dir_sda_reg$I2C_slave.vhd:310$307 ($dff) from module I2C_slave (D = $verific$n327$47, Q = \dir_sda).
Adding EN signal on $verific$data_w_reg$I2C_slave.vhd:310$309 ($dff) from module I2C_slave (D = $verific$n365$174, Q = \data_w).
Adding EN signal on $verific$data_read_reg_reg$I2C_slave.vhd:450$384 ($adff) from module I2C_slave (D = $verific$n780$191, Q = \data_read_reg).
Adding EN signal on $verific$data_r_reg$I2C_slave.vhd:450$382 ($adff) from module I2C_slave (D = \data_read_reg, Q = \data_r).
Adding EN signal on $verific$continue_reg_reg$I2C_slave.vhd:578$444 ($adff) from module I2C_slave (D = $verific$n1109$119, Q = \continue_reg).
Adding EN signal on $verific$bits_w_processed_reg_reg$I2C_slave.vhd:536$429 ($adff) from module I2C_slave (D = $verific$n1065$204, Q = \bits_w_processed_reg).
Adding EN signal on $verific$bits_r_processed_reg_reg$I2C_slave.vhd:450$383 ($adff) from module I2C_slave (D = $verific$n766$189, Q = \bits_r_processed_reg).

3.6.7.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 9 unused cells and 9 unused wires.
<suppressed ~10 debug messages>

3.6.7.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.7.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.7.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~46 debug messages>

3.6.7.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.7.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~9 debug messages>
Removed a total of 3 cells.

3.6.7.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 0 unused cells and 3 unused wires.
<suppressed ~1 debug messages>

3.6.7.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.7.16. Rerunning OPT passes. (Maybe there is more to do..)

3.6.7.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~46 debug messages>

3.6.7.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.7.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.7.20. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.7.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.7.23. Finished OPT passes. (There is nothing left to do.)

3.6.8. Executing WREDUCE pass (reducing word size of cells).
Removed top 3 bits (of 5) from port B of cell I2C_slave.$auto$opt_dff.cc:195:make_patterns_logic$519 ($ne).
Removed top 2 bits (of 4) from port B of cell I2C_slave.$auto$opt_dff.cc:195:make_patterns_logic$517 ($ne).
Removed top 1 bits (of 3) from port B of cell I2C_slave.$auto$opt_dff.cc:195:make_patterns_logic$495 ($ne).
Removed top 2 bits (of 3) from port B of cell I2C_slave.$auto$opt_dff.cc:195:make_patterns_logic$480 ($ne).
Removed top 1 bits (of 3) from mux cell I2C_slave.$verific$mux_50$I2C_slave.vhd:203$232 ($mux).
Removed top 2 bits (of 4) from port B of cell I2C_slave.$auto$opt_dff.cc:195:make_patterns_logic$471 ($ne).
Removed top 3 bits (of 4) from port B of cell I2C_slave.$verific$add_241$I2C_slave.vhd:436$359 ($add).
Removed top 1 bits (of 5) from port Y of cell I2C_slave.$verific$add_241$I2C_slave.vhd:436$359 ($add).
Removed top 2 bits (of 3) from port B of cell I2C_slave.$verific$add_314$I2C_slave.vhd:525$407 ($add).
Removed top 1 bits (of 4) from port Y of cell I2C_slave.$verific$add_314$I2C_slave.vhd:525$407 ($add).
Removed top 1 bits (of 3) from wire I2C_slave.$verific$n112$143.

3.6.9. Executing PEEPOPT pass (run peephole optimizers).

3.6.10. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 0 unused cells and 3 unused wires.
<suppressed ~1 debug messages>

3.6.11. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module I2C_slave:
  creating $macc model for $verific$add_241$I2C_slave.vhd:436$359 ($add).
  creating $macc model for $verific$add_314$I2C_slave.vhd:525$407 ($add).
  creating $alu model for $macc $verific$add_314$I2C_slave.vhd:525$407.
  creating $alu model for $macc $verific$add_241$I2C_slave.vhd:436$359.
  creating $alu model for $verific$LessThan_240$I2C_slave.vhd:435$358 ($lt): new $alu
  creating $alu model for $verific$LessThan_312$I2C_slave.vhd:523$405 ($lt): new $alu
  creating $alu model for $verific$equal_246$I2C_slave.vhd:441$365 ($eq): merged with $verific$LessThan_240$I2C_slave.vhd:435$358.
  creating $alu model for $verific$equal_316$I2C_slave.vhd:526$410 ($eq): merged with $verific$LessThan_312$I2C_slave.vhd:523$405.
  creating $alu cell for $verific$LessThan_312$I2C_slave.vhd:523$405, $verific$equal_316$I2C_slave.vhd:526$410: $auto$alumacc.cc:485:replace_alu$525
  creating $alu cell for $verific$LessThan_240$I2C_slave.vhd:435$358, $verific$equal_246$I2C_slave.vhd:441$365: $auto$alumacc.cc:485:replace_alu$536
  creating $alu cell for $verific$add_241$I2C_slave.vhd:436$359: $auto$alumacc.cc:485:replace_alu$543
  creating $alu cell for $verific$add_314$I2C_slave.vhd:525$407: $auto$alumacc.cc:485:replace_alu$546
  created 4 $alu and 0 $macc cells.

3.6.12. Executing SHARE pass (SAT-based resource sharing).

3.6.13. Executing OPT pass (performing simple optimizations).

3.6.13.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~5 debug messages>

3.6.13.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.13.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~46 debug messages>

3.6.13.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
    New input vector for $reduce_and cell $auto$opt_dff.cc:220:make_patterns_logic$504: { $auto$alumacc.cc:501:replace_alu$537 $auto$rtlil.cc:2359:Not$502 \enable_module_r }
  Optimizing cells in module \I2C_slave.
Performed a total of 1 changes.

3.6.13.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.13.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.13.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 0 unused cells and 4 unused wires.
<suppressed ~1 debug messages>

3.6.13.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.13.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.13.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \I2C_slave..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~46 debug messages>

3.6.13.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \I2C_slave.
Performed a total of 0 changes.

3.6.13.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
Removed a total of 0 cells.

3.6.13.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.13.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.13.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.

3.6.13.16. Finished OPT passes. (There is nothing left to do.)

3.6.14. Executing MEMORY pass.

3.6.14.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.6.14.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.6.14.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.6.14.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.6.14.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.6.14.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.14.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.6.14.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.6.14.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.6.14.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.6.15. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..

3.7. Executing EXTRACT_COUNTER pass (find counters in netlist).

3.8. Executing TECHMAP pass (map to technology primitives).

3.8.1. Executing Verilog-2005 frontend: /opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_counter_map.v
Parsing Verilog input from `/opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_counter_map.v' to AST representation.
Generating RTLIL representation for module `\$__COUNT_'.
Successfully finished Verilog frontend.

3.8.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~3 debug messages>

3.9. Executing OPT pass (performing simple optimizations).

3.9.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~65 debug messages>

3.9.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.9.3. Executing OPT_DFF pass (perform DFF optimizations).

3.9.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 3 unused cells and 45 unused wires.
<suppressed ~4 debug messages>

3.9.5. Finished fast OPT passes.

3.10. Executing TECHMAP pass (map to technology primitives).

3.10.1. Executing Verilog-2005 frontend: /opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/techmap.v
Parsing Verilog input from `/opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.10.2. Executing Verilog-2005 frontend: /opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_latch.v
Parsing Verilog input from `/opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/cells_latch.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Successfully finished Verilog frontend.

3.10.3. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $reduce_and.
Using extmapper simplemap for cells of type $ne.
Using extmapper simplemap for cells of type $adffe.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $bmux.
Using extmapper simplemap for cells of type $adff.
Using extmapper simplemap for cells of type $dffe.
Using template $paramod$3ef7d3dd227da7627a99c5e5a6a4deb817573e39\_90_alu for cells of type $alu.
Using template $paramod$32a7b7b86c07519b7537abc18e96f0331f97914d\_90_alu for cells of type $alu.
Using template $paramod$fc972a7a46956c1788f3cb5257b53c8f1df2d0cc\_90_alu for cells of type $alu.
Using extmapper simplemap for cells of type $tribuf.
Using extmapper simplemap for cells of type $xor.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000000011 for cells of type $lcu.
Using extmapper simplemap for cells of type $pos.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000000100 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=32'00000000000000000000000000000001 for cells of type $lcu.
No more expansions possible.
<suppressed ~667 debug messages>

3.11. Executing OPT pass (performing simple optimizations).

3.11.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~170 debug messages>

3.11.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~117 debug messages>
Removed a total of 39 cells.

3.11.3. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $auto$ff.cc:262:slice$1252 ($_DFF_PN0_) from module I2C_slave (D = $verific$n389$176 [2], Q = \sm_state [2]).
Adding EN signal on $auto$ff.cc:262:slice$1250 ($_DFF_PN0_) from module I2C_slave (D = $verific$n389$176 [0], Q = \sm_state [0]).
Adding EN signal on $auto$ff.cc:262:slice$1251 ($_DFF_PN0_) from module I2C_slave (D = $verific$n389$176 [1], Q = \sm_state [1]).

3.11.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 5 unused cells and 180 unused wires.
<suppressed ~6 debug messages>

3.11.5. Rerunning OPT passes. (Removed registers in this run.)

3.11.6. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~109 debug messages>

3.11.7. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~279 debug messages>
Removed a total of 93 cells.

3.11.8. Executing OPT_DFF pass (perform DFF optimizations).
Adding EN signal on $auto$ff.cc:262:slice$1279 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [11], Q = \data_r_reg [3]).
Adding EN signal on $auto$ff.cc:262:slice$1277 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [9], Q = \data_r_reg [1]).
Adding EN signal on $auto$ff.cc:262:slice$1278 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [10], Q = \data_r_reg [2]).
Adding EN signal on $auto$ff.cc:262:slice$1272 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [4], Q = \data_to_master_reg [4]).
Adding EN signal on $auto$ff.cc:262:slice$1273 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [5], Q = \data_to_master_reg [5]).
Adding EN signal on $auto$ff.cc:262:slice$1274 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [6], Q = \data_to_master_reg [6]).
Adding EN signal on $auto$ff.cc:262:slice$1275 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [7], Q = \data_to_master_reg [7]).
Adding EN signal on $auto$ff.cc:262:slice$1276 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [8], Q = \data_r_reg [0]).
Adding EN signal on $auto$ff.cc:262:slice$1271 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [3], Q = \data_to_master_reg [3]).
Adding EN signal on $auto$ff.cc:262:slice$1268 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [0], Q = \data_to_master_reg [0]).
Adding EN signal on $auto$ff.cc:262:slice$1270 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [2], Q = \data_to_master_reg [2]).
Adding EN signal on $auto$ff.cc:262:slice$1269 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1091 [1], Q = \data_to_master_reg [1]).
Adding EN signal on $auto$ff.cc:262:slice$1263 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [3], Q = \addr_reg [3]).
Adding EN signal on $auto$ff.cc:262:slice$1264 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [4], Q = \addr_reg [4]).
Adding EN signal on $auto$ff.cc:262:slice$1265 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [5], Q = \addr_reg [5]).
Adding EN signal on $auto$ff.cc:262:slice$1266 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [6], Q = \addr_reg [6]).
Adding EN signal on $auto$ff.cc:262:slice$1267 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1019, Q = \cmd_reg).
Adding EN signal on $auto$ff.cc:262:slice$1253 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$947, Q = \done_flag).
Adding EN signal on $auto$ff.cc:262:slice$1260 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [0], Q = \addr_reg [0]).
Adding EN signal on $auto$ff.cc:262:slice$1261 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [1], Q = \addr_reg [1]).
Adding EN signal on $auto$ff.cc:262:slice$1262 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1003 [2], Q = \addr_reg [2]).
Adding EN signal on $auto$ff.cc:262:slice$1280 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [12], Q = \data_r_reg [4]).
Adding EN signal on $auto$ff.cc:262:slice$1281 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [13], Q = \data_r_reg [5]).
Adding EN signal on $auto$ff.cc:262:slice$1282 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [14], Q = \data_r_reg [6]).
Adding EN signal on $auto$ff.cc:262:slice$1285 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [1], Q = \data_w [1]).
Adding EN signal on $auto$ff.cc:262:slice$1466 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$913, Q = \dir_sda).
Adding EN signal on $auto$ff.cc:262:slice$1286 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [2], Q = \data_w [2]).
Adding EN signal on $auto$ff.cc:262:slice$1284 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [0], Q = \data_w [0]).
Adding EN signal on $auto$ff.cc:262:slice$1283 ($_DFF_PN0_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1153 [15], Q = \data_r_reg [7]).
Adding EN signal on $auto$ff.cc:262:slice$1287 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [3], Q = \data_w [3]).
Adding EN signal on $auto$ff.cc:262:slice$1290 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [6], Q = \data_w [6]).
Adding EN signal on $auto$ff.cc:262:slice$1291 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [7], Q = \data_w [7]).
Adding EN signal on $auto$ff.cc:262:slice$1288 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [4], Q = \data_w [4]).
Adding EN signal on $auto$ff.cc:262:slice$1289 ($_DFFE_PP_) from module I2C_slave (D = $auto$simplemap.cc:309:simplemap_bmux$1229 [5], Q = \data_w [5]).
Adding EN signal on $auto$ff.cc:262:slice$1859 ($_DFFE_PN0P_) from module I2C_slave (D = $verific$n389$176 [1], Q = \sm_state [1]).

3.11.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 8 unused cells and 304 unused wires.
<suppressed ~9 debug messages>

3.11.10. Rerunning OPT passes. (Removed registers in this run.)

3.11.11. Executing OPT_EXPR pass (perform const folding).
Optimizing module I2C_slave.
<suppressed ~705 debug messages>

3.11.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\I2C_slave'.
<suppressed ~2616 debug messages>
Removed a total of 872 cells.

3.11.13. Executing OPT_DFF pass (perform DFF optimizations).

3.11.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \I2C_slave..
Removed 0 unused cells and 892 unused wires.
<suppressed ~1 debug messages>

3.11.15. Finished fast OPT passes.

3.12. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
  cell FDCP_N (noninv, pins=5, area=1.00) is a direct match for cell type $_DFFSR_NPP_.
  cell FDCP (noninv, pins=5, area=1.00) is a direct match for cell type $_DFFSR_PPP_.
  final dff cell mappings:
    unmapped dff cell: $_DFF_N_
    unmapped dff cell: $_DFF_P_
    unmapped dff cell: $_DFF_NN0_
    unmapped dff cell: $_DFF_NN1_
    unmapped dff cell: $_DFF_NP0_
    unmapped dff cell: $_DFF_NP1_
    unmapped dff cell: $_DFF_PN0_
    unmapped dff cell: $_DFF_PN1_
    unmapped dff cell: $_DFF_PP0_
    unmapped dff cell: $_DFF_PP1_
    unmapped dff cell: $_DFFSR_NNN_
    unmapped dff cell: $_DFFSR_NNP_
    unmapped dff cell: $_DFFSR_NPN_
    \FDCP_N _DFFSR_NPP_ (.C( C), .CLR( R), .D( D), .PRE( S), .Q( Q));
    unmapped dff cell: $_DFFSR_PNN_
    unmapped dff cell: $_DFFSR_PNP_
    unmapped dff cell: $_DFFSR_PPN_
    \FDCP _DFFSR_PPP_ (.C( C), .CLR( R), .D( D), .PRE( S), .Q( Q));

3.12.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).

3.13. Executing ABC pass (technology mapping using ABC).

3.13.1. Extracting gate netlist of module `\I2C_slave' to `<abc-temp-dir>/input.blif'..
Extracted 668 gates and 780 wires to a netlist network with 109 inputs and 171 outputs.

3.13.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 6 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.13.1.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       12
ABC RESULTS:               AND cells:      416
ABC RESULTS:               NOT cells:      422
ABC RESULTS:        internal signals:      500
ABC RESULTS:           input signals:      109
ABC RESULTS:          output signals:      171
Removing temp directory.
Removed 0 unused cells and 509 unused wires.

3.14. Executing EXTRACT pass (map subcircuits to cells).

3.14.1. Executing Verilog-2005 frontend: /opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/tff_extract.v
Parsing Verilog input from `/opt/sonarqube/tabby-linux-x64-20220610/tabby/lib/../share/yosys/coolrunner2/tff_extract.v' to AST representation.
Generating RTLIL representation for module `\FTCP'.
Generating RTLIL representation for module `\FTCP_N'.
Successfully finished Verilog frontend.

3.14.2. Executing PROC pass (convert processes to netlists).

3.14.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.14.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

3.14.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

3.14.2.4. Executing PROC_INIT pass (extract init attributes).

3.14.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.14.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

3.14.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

3.14.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).

3.14.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.14.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.14.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.14.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module FTCP_N.
Optimizing module FTCP.

3.14.3. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \FTCP_N..
Finding unused cells or wires in module \FTCP..

3.14.4. Creating graphs for SubCircuit library.
Creating needle graph needle_FTCP.
Creating needle graph needle_FTCP_N.
Creating haystack graph haystack_ANDTERM.
Creating haystack graph haystack_BUFG.
Creating haystack graph haystack_BUFGSR.
Creating haystack graph haystack_BUFGTS.
Creating haystack graph haystack_FDCP.
Creating haystack graph haystack_FDCPE.
Creating haystack graph haystack_FDCPE_N.
Creating haystack graph haystack_FDCP_N.
Creating haystack graph haystack_FDDCP.
Creating haystack graph haystack_FDDCPE.
Creating haystack graph haystack_FTCP.
Creating haystack graph haystack_FTCP_N.
Creating haystack graph haystack_FTDCP.
Creating haystack graph haystack_I2C_slave.
Creating haystack graph haystack_IBUF.
Creating haystack graph haystack_IOBUFE.
Creating haystack graph haystack_LDCP.
Creating haystack graph haystack_LDCP_N.
Creating haystack graph haystack_MACROCELL_XOR.
Creating haystack graph haystack_ORTERM.

3.14.5. Running solver from SubCircuit library.
Solving for needle_FTCP in haystack_ANDTERM.
Solving for needle_FTCP in haystack_BUFG.
Solving for needle_FTCP in haystack_BUFGSR.
Solving for needle_FTCP in haystack_BUFGTS.
Solving for needle_FTCP in haystack_FDCP.
Solving for needle_FTCP in haystack_FDCPE.
Solving for needle_FTCP in haystack_FDCPE_N.
Solving for needle_FTCP in haystack_FDCP_N.
Solving for needle_FTCP in haystack_FDDCP.
Solving for needle_FTCP in haystack_FDDCPE.
Solving for needle_FTCP in haystack_FTCP.
Solving for needle_FTCP in haystack_FTCP_N.
Solving for needle_FTCP in haystack_FTDCP.
Solving for needle_FTCP in haystack_I2C_slave.
Solving for needle_FTCP in haystack_IBUF.
Solving for needle_FTCP in haystack_IOBUFE.
Solving for needle_FTCP in haystack_LDCP.
Solving for needle_FTCP in haystack_LDCP_N.
Solving for needle_FTCP in haystack_MACROCELL_XOR.
Solving for needle_FTCP in haystack_ORTERM.
Solving for needle_FTCP_N in haystack_ANDTERM.
Solving for needle_FTCP_N in haystack_BUFG.
Solving for needle_FTCP_N in haystack_BUFGSR.
Solving for needle_FTCP_N in haystack_BUFGTS.
Solving for needle_FTCP_N in haystack_FDCP.
Solving for needle_FTCP_N in haystack_FDCPE.
Solving for needle_FTCP_N in haystack_FDCPE_N.
Solving for needle_FTCP_N in haystack_FDCP_N.
Solving for needle_FTCP_N in haystack_FDDCP.
Solving for needle_FTCP_N in haystack_FDDCPE.
Solving for needle_FTCP_N in haystack_FTCP.
Solving for needle_FTCP_N in haystack_FTCP_N.
Solving for needle_FTCP_N in haystack_FTDCP.
Solving for needle_FTCP_N in haystack_I2C_slave.
Solving for needle_FTCP_N in haystack_IBUF.
Solving for needle_FTCP_N in haystack_IOBUFE.
Solving for needle_FTCP_N in haystack_LDCP.
Solving for needle_FTCP_N in haystack_LDCP_N.
Solving for needle_FTCP_N in haystack_MACROCELL_XOR.
Solving for needle_FTCP_N in haystack_ORTERM.
Found 0 matches.

3.15. Executing ABC pass (technology mapping using ABC).

3.15.1. Extracting gate netlist of module `\I2C_slave' to `<abc-temp-dir>/input.blif'..
Extracted 850 gates and 959 wires to a netlist network with 109 inputs and 171 outputs.

3.15.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + strash 
ABC: + dch -f 
ABC: + cover -I 40 -P 56 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.15.1.2. Re-integrating ABC results.
ABC RESULTS:            $_NOT_ cells:       10
ABC RESULTS:              $sop cells:      186
ABC RESULTS:        internal signals:      679
ABC RESULTS:           input signals:      109
ABC RESULTS:          output signals:      171
Removing temp directory.
Removed 0 unused cells and 959 unused wires.

3.16. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
  cell FDCP_N (noninv, pins=5, area=1.00) is a direct match for cell type $_DFFSR_NPP_.
  cell FDCP (noninv, pins=5, area=1.00) is a direct match for cell type $_DFFSR_PPP_.
  final dff cell mappings:
    unmapped dff cell: $_DFF_N_
    unmapped dff cell: $_DFF_P_
    unmapped dff cell: $_DFF_NN0_
    unmapped dff cell: $_DFF_NN1_
    unmapped dff cell: $_DFF_NP0_
    unmapped dff cell: $_DFF_NP1_
    unmapped dff cell: $_DFF_PN0_
    unmapped dff cell: $_DFF_PN1_
    unmapped dff cell: $_DFF_PP0_
    unmapped dff cell: $_DFF_PP1_
    unmapped dff cell: $_DFFSR_NNN_
    unmapped dff cell: $_DFFSR_NNP_
    unmapped dff cell: $_DFFSR_NPN_
    \FDCP_N _DFFSR_NPP_ (.C( C), .CLR( R), .D( D), .PRE( S), .Q( Q));
    unmapped dff cell: $_DFFSR_PNN_
    unmapped dff cell: $_DFFSR_PNP_
    unmapped dff cell: $_DFFSR_PPN_
    \FDCP _DFFSR_PPP_ (.C( C), .CLR( R), .D( D), .PRE( S), .Q( Q));

3.16.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
Mapping DFF cells in module `\I2C_slave':
  mapped 92 $_DFFSR_PPP_ cells to \FDCP cells.

3.17. Executing DFFINIT pass (set INIT param on FF cells).
Setting I2C_slave.$auto$ff.cc:262:slice$4809.INIT (port=Q, net=\sm_state [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$672.INIT (port=Q, net=\w_done_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1254.INIT (port=Q, net=\en_r) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1255.INIT (port=Q, net=\en_slave_ack) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1256.INIT (port=Q, net=\en_w) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1257.INIT (port=Q, net=\en_master_ack) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1258.INIT (port=Q, net=\data_valid_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1259.INIT (port=Q, net=\read_req_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1292.INIT (port=Q, net=\data_read_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1293.INIT (port=Q, net=\data_read_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1294.INIT (port=Q, net=\data_read_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1295.INIT (port=Q, net=\data_read_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1296.INIT (port=Q, net=\data_read_reg [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1297.INIT (port=Q, net=\data_read_reg [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1298.INIT (port=Q, net=\data_read_reg [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1299.INIT (port=Q, net=\data_read_reg [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1300.INIT (port=Q, net=\d_data_valid_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1303.INIT (port=Q, net=\scl_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1304.INIT (port=Q, net=\scl_prev_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1313.INIT (port=Q, net=\sda_reg_start) to 1'1.
Setting I2C_slave.$auto$ff.cc:262:slice$1314.INIT (port=Q, net=\sda_prev_reg_start) to 1'1.
Setting I2C_slave.$auto$ff.cc:262:slice$1315.INIT (port=Q, net=\r_done_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1331.INIT (port=Q, net=\start_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1376.INIT (port=Q, net=\end_slave_ack_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1377.INIT (port=Q, net=\continue_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1378.INIT (port=Q, net=\data_r [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1379.INIT (port=Q, net=\data_r [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1380.INIT (port=Q, net=\data_r [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1381.INIT (port=Q, net=\data_r [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1382.INIT (port=Q, net=\data_r [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1383.INIT (port=Q, net=\data_r [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1384.INIT (port=Q, net=\data_r [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1385.INIT (port=Q, net=\data_r [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1386.INIT (port=Q, net=\enable_module_r) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1390.INIT (port=Q, net=\sda_slave_ack_reg) to 1'1.
Setting I2C_slave.$auto$ff.cc:262:slice$1391.INIT (port=Q, net=\end_master_ack_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1392.INIT (port=Q, net=\enable_module_slave_ack) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1448.INIT (port=Q, net=\sda_w_reg) to 1'1.
Setting I2C_slave.$auto$ff.cc:262:slice$1449.INIT (port=Q, net=\stop_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1450.INIT (port=Q, net=\bits_r_processed_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1451.INIT (port=Q, net=\bits_r_processed_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1452.INIT (port=Q, net=\bits_r_processed_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1453.INIT (port=Q, net=\bits_r_processed_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1454.INIT (port=Q, net=\data_w_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1455.INIT (port=Q, net=\data_w_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1456.INIT (port=Q, net=\data_w_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1457.INIT (port=Q, net=\data_w_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1458.INIT (port=Q, net=\data_w_reg [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1459.INIT (port=Q, net=\data_w_reg [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1460.INIT (port=Q, net=\data_w_reg [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1461.INIT (port=Q, net=\data_w_reg [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1462.INIT (port=Q, net=\enable_module_w) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1467.INIT (port=Q, net=\bits_w_processed_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1468.INIT (port=Q, net=\bits_w_processed_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1469.INIT (port=Q, net=\bits_w_processed_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1470.INIT (port=Q, net=\enable_module_master_ack) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1613.INIT (port=Q, net=\sm_state [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$1736.INIT (port=Q, net=\sm_state [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2038.INIT (port=Q, net=\data_r_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2076.INIT (port=Q, net=\data_r_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2114.INIT (port=Q, net=\data_r_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2152.INIT (port=Q, net=\data_to_master_reg [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2335.INIT (port=Q, net=\data_to_master_reg [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2518.INIT (port=Q, net=\data_to_master_reg [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2701.INIT (port=Q, net=\data_to_master_reg [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2884.INIT (port=Q, net=\data_r_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$2922.INIT (port=Q, net=\data_to_master_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3105.INIT (port=Q, net=\data_to_master_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3288.INIT (port=Q, net=\data_to_master_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3471.INIT (port=Q, net=\data_to_master_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3654.INIT (port=Q, net=\addr_reg [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3720.INIT (port=Q, net=\addr_reg [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3786.INIT (port=Q, net=\addr_reg [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3852.INIT (port=Q, net=\addr_reg [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3918.INIT (port=Q, net=\cmd_reg) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$3984.INIT (port=Q, net=\done_flag) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4026.INIT (port=Q, net=\addr_reg [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4092.INIT (port=Q, net=\addr_reg [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4158.INIT (port=Q, net=\addr_reg [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4224.INIT (port=Q, net=\data_r_reg [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4262.INIT (port=Q, net=\data_r_reg [5]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4300.INIT (port=Q, net=\data_r_reg [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4338.INIT (port=Q, net=\data_w [1]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4390.INIT (port=Q, net=\dir_sda) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4407.INIT (port=Q, net=\data_w [2]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4459.INIT (port=Q, net=\data_w [0]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4511.INIT (port=Q, net=\data_r_reg [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4549.INIT (port=Q, net=\data_w [3]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4601.INIT (port=Q, net=\data_w [6]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4653.INIT (port=Q, net=\data_w [7]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4705.INIT (port=Q, net=\data_w [4]) to 1'0.
Setting I2C_slave.$auto$ff.cc:262:slice$4757.INIT (port=Q, net=\data_w [5]) to 1'0.

3.18. Executing DFFINIT pass (set INIT param on FF cells).

3.19. Executing DFFINIT pass (set INIT param on FF cells).

3.20. Executing DFFINIT pass (set INIT param on FF cells).

3.21. Executing DFFINIT pass (set INIT param on FF cells).

3.22. Executing DFFINIT pass (set INIT param on FF cells).

3.23. Executing COOLRUNNER2_SOP pass (break $sop cells into ANDTERM/ORTERM cells).
Removed 81 unused cells and 91 unused wires.

3.24. Executing IOPADMAP pass (mapping inputs/outputs to IO-PAD cells).
Mapping port I2C_slave.b_sda[0] using IOBUFE.
Mapping port I2C_slave.i_clk using IBUF.
Mapping port I2C_slave.i_data_w using IBUF.
Mapping port I2C_slave.i_rst_n using IBUF.
Mapping port I2C_slave.i_rx_mode using IBUF.
Mapping port I2C_slave.i_scl using IBUF.
Mapping port I2C_slave.i_slave_addr using IBUF.
Mapping port I2C_slave.o_data_r using IOBUFE.
Mapping port I2C_slave.o_read_req using IOBUFE.
Mapping port I2C_slave.o_vz using IOBUFE.

3.25. Executing ATTRMVCP pass (move or copy attributes).
Moving attribute src="I2C_slave.vhd:33" from I2C_slave.b_sda to I2C_slave.$iopadmap$I2C_slave.b_sda[0].
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_1.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_2.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_3.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_4.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_5.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_6.
Moving attribute src="I2C_slave.vhd:36" from I2C_slave.o_data_r to I2C_slave.$iopadmap$I2C_slave.o_data_r_7.
Moving attribute src="I2C_slave.vhd:37" from I2C_slave.o_read_req to I2C_slave.$iopadmap$I2C_slave.o_read_req.
Moving attribute src="I2C_slave.vhd:38" from I2C_slave.o_vz to I2C_slave.$iopadmap$I2C_slave.o_vz.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$4026.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$4092.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$4158.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$3654.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$3720.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$3786.
Moving attribute src="I2C_slave.vhd:81" from I2C_slave.addr_reg to I2C_slave.$auto$ff.cc:262:slice$3852.
Moving attribute src="I2C_slave.vhd:98" from I2C_slave.bits_r_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1450.
Moving attribute src="I2C_slave.vhd:98" from I2C_slave.bits_r_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1451.
Moving attribute src="I2C_slave.vhd:98" from I2C_slave.bits_r_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1452.
Moving attribute src="I2C_slave.vhd:98" from I2C_slave.bits_r_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1453.
Moving attribute src="I2C_slave.vhd:109" from I2C_slave.bits_w_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1467.
Moving attribute src="I2C_slave.vhd:109" from I2C_slave.bits_w_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1468.
Moving attribute src="I2C_slave.vhd:109" from I2C_slave.bits_w_processed_reg to I2C_slave.$auto$ff.cc:262:slice$1469.
Moving attribute src="I2C_slave.vhd:76" from I2C_slave.cmd_reg to I2C_slave.$auto$ff.cc:262:slice$3918.
Moving attribute src="I2C_slave.vhd:52" from I2C_slave.continue to I2C_slave.$auto$ff.cc:262:slice$1377.
Moving attribute src="I2C_slave.vhd:115" from I2C_slave.continue_reg to I2C_slave.$auto$ff.cc:262:slice$1377.
Moving attribute src="I2C_slave.vhd:78" from I2C_slave.d_data_valid_reg to I2C_slave.$auto$ff.cc:262:slice$1300.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1378.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1379.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1380.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1381.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1382.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1383.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1384.
Moving attribute src="I2C_slave.vhd:49" from I2C_slave.data_r to I2C_slave.$auto$ff.cc:262:slice$1385.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$2884.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$2076.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$2114.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$2038.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$4224.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$4262.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$4300.
Moving attribute src="I2C_slave.vhd:82" from I2C_slave.data_r_reg to I2C_slave.$auto$ff.cc:262:slice$4511.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1292.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1293.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1294.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1295.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1296.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1297.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1298.
Moving attribute src="I2C_slave.vhd:97" from I2C_slave.data_read_reg to I2C_slave.$auto$ff.cc:262:slice$1299.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$3105.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$3471.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$3288.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$2922.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$2152.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$2335.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$2518.
Moving attribute src="I2C_slave.vhd:83" from I2C_slave.data_to_master_reg to I2C_slave.$auto$ff.cc:262:slice$2701.
Moving attribute src="I2C_slave.vhd:77" from I2C_slave.data_valid_reg to I2C_slave.$auto$ff.cc:262:slice$1258.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4459.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4338.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4407.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4549.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4705.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4757.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4601.
Moving attribute src="I2C_slave.vhd:55" from I2C_slave.data_w to I2C_slave.$auto$ff.cc:262:slice$4653.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1454.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1455.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1456.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1457.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1458.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1459.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1460.
Moving attribute src="I2C_slave.vhd:108" from I2C_slave.data_w_reg to I2C_slave.$auto$ff.cc:262:slice$1461.
Moving attribute src="I2C_slave.vhd:59" from I2C_slave.dir_sda to I2C_slave.$auto$ff.cc:262:slice$4390.
Moving attribute src="I2C_slave.vhd:75" from I2C_slave.done_flag to I2C_slave.$auto$ff.cc:262:slice$3984.
Moving attribute src="I2C_slave.vhd:51" from I2C_slave.en_master_ack to I2C_slave.$auto$ff.cc:262:slice$1257.
Moving attribute src="I2C_slave.vhd:48" from I2C_slave.en_r to I2C_slave.$auto$ff.cc:262:slice$1254.
Moving attribute src="I2C_slave.vhd:57" from I2C_slave.en_slave_ack to I2C_slave.$auto$ff.cc:262:slice$1255.
Moving attribute src="I2C_slave.vhd:54" from I2C_slave.en_w to I2C_slave.$auto$ff.cc:262:slice$1256.
Moving attribute src="I2C_slave.vhd:114" from I2C_slave.enable_module_master_ack to I2C_slave.$auto$ff.cc:262:slice$1470.
Moving attribute src="I2C_slave.vhd:96" from I2C_slave.enable_module_r to I2C_slave.$auto$ff.cc:262:slice$1386.
Moving attribute src="I2C_slave.vhd:102" from I2C_slave.enable_module_slave_ack to I2C_slave.$auto$ff.cc:262:slice$1392.
Moving attribute src="I2C_slave.vhd:107" from I2C_slave.enable_module_w to I2C_slave.$auto$ff.cc:262:slice$1462.
Moving attribute src="I2C_slave.vhd:53" from I2C_slave.end_master_ack to I2C_slave.$auto$ff.cc:262:slice$1391.
Moving attribute src="I2C_slave.vhd:116" from I2C_slave.end_master_ack_reg to I2C_slave.$auto$ff.cc:262:slice$1391.
Moving attribute src="I2C_slave.vhd:58" from I2C_slave.end_slave_ack to I2C_slave.$auto$ff.cc:262:slice$1376.
Moving attribute src="I2C_slave.vhd:103" from I2C_slave.end_slave_ack_reg to I2C_slave.$auto$ff.cc:262:slice$1376.
Moving attribute src="I2C_slave.vhd:120" from I2C_slave.i_scl_int to I2C_slave.$iopadmap$I2C_slave.i_scl.
Moving attribute src="I2C_slave.vhd:50" from I2C_slave.r_done to I2C_slave.$auto$ff.cc:262:slice$1315.
Moving attribute src="I2C_slave.vhd:99" from I2C_slave.r_done_reg to I2C_slave.$auto$ff.cc:262:slice$1315.
Moving attribute src="I2C_slave.vhd:79" from I2C_slave.re_data_valid_reg to I2C_slave.$xc2sop$\o_vz_XOR.
Moving attribute src="I2C_slave.vhd:80" from I2C_slave.read_req_reg to I2C_slave.$auto$ff.cc:262:slice$1259.
Moving attribute src="I2C_slave.vhd:86" from I2C_slave.scl_prev_reg to I2C_slave.$auto$ff.cc:262:slice$1304.
Moving attribute src="I2C_slave.vhd:85" from I2C_slave.scl_reg to I2C_slave.$auto$ff.cc:262:slice$1303.
Moving attribute src="I2C_slave.vhd:117" from I2C_slave.sda_master_ack to I2C_slave.$xc2sop$\sda_master_ack_XOR.
Moving attribute src="I2C_slave.vhd:88" from I2C_slave.sda_prev_reg_start to I2C_slave.$auto$ff.cc:262:slice$1314.
Moving attribute src="I2C_slave.vhd:90" from I2C_slave.sda_prev_reg_stop to I2C_slave.$auto$ff.cc:262:slice$1314.
Moving attribute src="I2C_slave.vhd:100" from I2C_slave.sda_r to I2C_slave.$xc2sop$\sda_master_ack_XOR.
Moving attribute src="I2C_slave.vhd:87" from I2C_slave.sda_reg_start to I2C_slave.$auto$ff.cc:262:slice$1313.
Moving attribute src="I2C_slave.vhd:89" from I2C_slave.sda_reg_stop to I2C_slave.$auto$ff.cc:262:slice$1313.
Moving attribute src="I2C_slave.vhd:105" from I2C_slave.sda_slave_ack to I2C_slave.$auto$ff.cc:262:slice$1390.
Moving attribute src="I2C_slave.vhd:104" from I2C_slave.sda_slave_ack_reg to I2C_slave.$auto$ff.cc:262:slice$1390.
Moving attribute src="I2C_slave.vhd:93" from I2C_slave.sda_start to I2C_slave.$xc2sop$\sda_master_ack_XOR.
Moving attribute src="I2C_slave.vhd:94" from I2C_slave.sda_stop to I2C_slave.$xc2sop$\sda_master_ack_XOR.
Moving attribute src="I2C_slave.vhd:112" from I2C_slave.sda_w to I2C_slave.$auto$ff.cc:262:slice$1448.
Moving attribute src="I2C_slave.vhd:111" from I2C_slave.sda_w_reg to I2C_slave.$auto$ff.cc:262:slice$1448.
Moving attribute src="I2C_slave.vhd:74" from I2C_slave.sm_state to I2C_slave.$auto$ff.cc:262:slice$1736.
Moving attribute src="I2C_slave.vhd:74" from I2C_slave.sm_state to I2C_slave.$auto$ff.cc:262:slice$4809.
Moving attribute src="I2C_slave.vhd:74" from I2C_slave.sm_state to I2C_slave.$auto$ff.cc:262:slice$1613.
Moving attribute src="I2C_slave.vhd:46" from I2C_slave.start_done to I2C_slave.$auto$ff.cc:262:slice$1331.
Moving attribute src="I2C_slave.vhd:91" from I2C_slave.start_reg to I2C_slave.$auto$ff.cc:262:slice$1331.
Moving attribute src="I2C_slave.vhd:47" from I2C_slave.stop_done to I2C_slave.$auto$ff.cc:262:slice$1449.
Moving attribute src="I2C_slave.vhd:92" from I2C_slave.stop_reg to I2C_slave.$auto$ff.cc:262:slice$1449.
Moving attribute src="I2C_slave.vhd:56" from I2C_slave.w_done to I2C_slave.$auto$ff.cc:262:slice$672.
Moving attribute src="I2C_slave.vhd:110" from I2C_slave.w_done_reg to I2C_slave.$auto$ff.cc:262:slice$672.

3.26. Executing ATTRMVCP pass (move or copy attributes).
Moving attribute src="I2C_slave.vhd:29" from I2C_slave.i_clk to I2C_slave.$iopadmap$I2C_slave.i_clk.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_1.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_2.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_3.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_4.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_5.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_6.
Moving attribute src="I2C_slave.vhd:35" from I2C_slave.i_data_w to I2C_slave.$iopadmap$I2C_slave.i_data_w_7.
Moving attribute src="I2C_slave.vhd:30" from I2C_slave.i_rst_n to I2C_slave.$iopadmap$I2C_slave.i_rst_n.
Moving attribute src="I2C_slave.vhd:40" from I2C_slave.i_rx_mode to I2C_slave.$iopadmap$I2C_slave.i_rx_mode.
Moving attribute src="I2C_slave.vhd:32" from I2C_slave.i_scl to I2C_slave.$iopadmap$I2C_slave.i_scl.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_1.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_2.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_3.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_4.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_5.
Moving attribute src="I2C_slave.vhd:39" from I2C_slave.i_slave_addr to I2C_slave.$iopadmap$I2C_slave.i_slave_addr_6.

3.27. Executing COOLRUNNER2_FIXUP pass (insert necessary buffer cells for CoolRunner-II architecture).
Found IBUF $iopadmap$i_scl that can be packed with FF $auto$ff.cc:262:slice$1303 (type \FDCP)
Buffering clock to "$auto$ff.cc:262:slice$1254"
Buffering clock to "$auto$ff.cc:262:slice$1255"
Buffering clock to "$auto$ff.cc:262:slice$1256"
Buffering clock to "$auto$ff.cc:262:slice$1257"
Buffering clock to "$auto$ff.cc:262:slice$1258"
Buffering clock to "$auto$ff.cc:262:slice$1259"
Buffering clock to "$auto$ff.cc:262:slice$1292"
Buffering clock to "$auto$ff.cc:262:slice$1293"
Buffering clock to "$auto$ff.cc:262:slice$1294"
Buffering clock to "$auto$ff.cc:262:slice$1295"
Buffering clock to "$auto$ff.cc:262:slice$1296"
Buffering clock to "$auto$ff.cc:262:slice$1297"
Buffering clock to "$auto$ff.cc:262:slice$1298"
Buffering clock to "$auto$ff.cc:262:slice$1299"
Buffering input to "$auto$ff.cc:262:slice$1300"
Buffering clock to "$auto$ff.cc:262:slice$1300"
Buffering clock to "$auto$ff.cc:262:slice$1303"
Buffering input to "$auto$ff.cc:262:slice$1304"
Buffering clock to "$auto$ff.cc:262:slice$1304"
Buffering clock to "$auto$ff.cc:262:slice$1313"
Buffering input to "$auto$ff.cc:262:slice$1314"
Buffering clock to "$auto$ff.cc:262:slice$1314"
Buffering clock to "$auto$ff.cc:262:slice$1315"
Buffering clock to "$auto$ff.cc:262:slice$1331"
Buffering clock to "$auto$ff.cc:262:slice$1376"
Buffering clock to "$auto$ff.cc:262:slice$1377"
Buffering clock to "$auto$ff.cc:262:slice$1378"
Buffering clock to "$auto$ff.cc:262:slice$1379"
Buffering clock to "$auto$ff.cc:262:slice$1380"
Buffering clock to "$auto$ff.cc:262:slice$1381"
Buffering clock to "$auto$ff.cc:262:slice$1382"
Buffering clock to "$auto$ff.cc:262:slice$1383"
Buffering clock to "$auto$ff.cc:262:slice$1384"
Buffering clock to "$auto$ff.cc:262:slice$1385"
Buffering clock to "$auto$ff.cc:262:slice$1386"
Buffering clock to "$auto$ff.cc:262:slice$1390"
Buffering clock to "$auto$ff.cc:262:slice$1391"
Buffering clock to "$auto$ff.cc:262:slice$1392"
Buffering clock to "$auto$ff.cc:262:slice$1448"
Buffering clock to "$auto$ff.cc:262:slice$1449"
Buffering clock to "$auto$ff.cc:262:slice$1450"
Buffering clock to "$auto$ff.cc:262:slice$1451"
Buffering clock to "$auto$ff.cc:262:slice$1452"
Buffering clock to "$auto$ff.cc:262:slice$1453"
Buffering clock to "$auto$ff.cc:262:slice$1454"
Buffering clock to "$auto$ff.cc:262:slice$1455"
Buffering clock to "$auto$ff.cc:262:slice$1456"
Buffering clock to "$auto$ff.cc:262:slice$1457"
Buffering clock to "$auto$ff.cc:262:slice$1458"
Buffering clock to "$auto$ff.cc:262:slice$1459"
Buffering clock to "$auto$ff.cc:262:slice$1460"
Buffering clock to "$auto$ff.cc:262:slice$1461"
Buffering clock to "$auto$ff.cc:262:slice$1462"
Buffering clock to "$auto$ff.cc:262:slice$1467"
Buffering clock to "$auto$ff.cc:262:slice$1468"
Buffering clock to "$auto$ff.cc:262:slice$1469"
Buffering clock to "$auto$ff.cc:262:slice$1470"
Buffering clock to "$auto$ff.cc:262:slice$1613"
Buffering clock to "$auto$ff.cc:262:slice$1736"
Buffering clock to "$auto$ff.cc:262:slice$2038"
Buffering clock to "$auto$ff.cc:262:slice$2076"
Buffering clock to "$auto$ff.cc:262:slice$2114"
Buffering clock to "$auto$ff.cc:262:slice$2152"
Buffering clock to "$auto$ff.cc:262:slice$2335"
Buffering clock to "$auto$ff.cc:262:slice$2518"
Buffering clock to "$auto$ff.cc:262:slice$2701"
Buffering clock to "$auto$ff.cc:262:slice$2884"
Buffering clock to "$auto$ff.cc:262:slice$2922"
Buffering clock to "$auto$ff.cc:262:slice$3105"
Buffering clock to "$auto$ff.cc:262:slice$3288"
Buffering clock to "$auto$ff.cc:262:slice$3471"
Buffering clock to "$auto$ff.cc:262:slice$3654"
Buffering clock to "$auto$ff.cc:262:slice$3720"
Buffering clock to "$auto$ff.cc:262:slice$3786"
Buffering clock to "$auto$ff.cc:262:slice$3852"
Buffering clock to "$auto$ff.cc:262:slice$3918"
Buffering clock to "$auto$ff.cc:262:slice$3984"
Buffering clock to "$auto$ff.cc:262:slice$4026"
Buffering clock to "$auto$ff.cc:262:slice$4092"
Buffering clock to "$auto$ff.cc:262:slice$4158"
Buffering clock to "$auto$ff.cc:262:slice$4224"
Buffering clock to "$auto$ff.cc:262:slice$4262"
Buffering clock to "$auto$ff.cc:262:slice$4300"
Buffering clock to "$auto$ff.cc:262:slice$4338"
Buffering clock to "$auto$ff.cc:262:slice$4390"
Buffering clock to "$auto$ff.cc:262:slice$4407"
Buffering clock to "$auto$ff.cc:262:slice$4459"
Buffering clock to "$auto$ff.cc:262:slice$4511"
Buffering clock to "$auto$ff.cc:262:slice$4549"
Buffering clock to "$auto$ff.cc:262:slice$4601"
Buffering clock to "$auto$ff.cc:262:slice$4653"
Buffering clock to "$auto$ff.cc:262:slice$4705"
Buffering clock to "$auto$ff.cc:262:slice$4757"
Buffering clock to "$auto$ff.cc:262:slice$4809"
Buffering clock to "$auto$ff.cc:262:slice$672"
Buffering input to "$iopadmap$I2C_slave.b_sda[0]"
Buffering output enable to "$iopadmap$I2C_slave.b_sda[0]"

3.28. Executing SPLITNETS pass (splitting up multi-bit signals).
Removed 0 unused cells and 11 unused wires.

3.29. Executing HIERARCHY pass (managing design hierarchy).

3.29.1. Analyzing design hierarchy..
Top module:  \I2C_slave

3.29.2. Analyzing design hierarchy..
Top module:  \I2C_slave
Removed 0 unused modules.

3.30. Printing statistics.

=== I2C_slave ===

   Number of wires:               1003
   Number of wire bits:           1023
   Number of public wires:         119
   Number of public wire bits:     139
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                989
     ANDTERM                       668
     FDCP                           92
     IBUF                           19
     IOBUFE                         11
     MACROCELL_XOR                 109
     ORTERM                         90

3.31. Executing CHECK pass (checking for obvious problems).
Checking module I2C_slave...
Found and reported 0 problems.
